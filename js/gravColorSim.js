import GravBody from '../js/gravBody.js'
import Vector2D from '../js/vector2d.js'
import GravFieldPoint from '../js/gravFieldPoint.js'

import { gravityOnPoint } from '../js/lawsOfPhysiscs.js'

// The Simulation of a static and colored Gravitational Field
export default class GravColorSim {
    constructor(canvas, PARAMETERS, CONSTANTS, COLORS) {
        this.canvas = canvas
        this.ctx = canvas.getContext('2d')

        this.SCALE = PARAMETERS.SCALE
        this.STEP = PARAMETERS.STEP

        this.CONSTANTS = CONSTANTS
        this.COLORS = COLORS

        // The gravitational intensities will be put on a scale between the two boundary colors, and colored accordingly
        this.minGrav = Infinity
        this.maxGrav = 0
    }

    // Start and Restart the Simulation
    start() {
        // Size of the canvas
        this.width = this.canvas.width
        this.height = this.canvas.height

        // Clear the canvas
        this.ctx.clearRect(0, 0, this.width, this.height)

        // Get the Simulation Parameters
        this.getParameters()

        // Define points according to the Parameters
        this.getPoints()

        // List with all the bodies in the simulation
        this.bodies = []

        // Draw the current Gravitational Field
        this.draw()

        // Get the array of all possible colors
        this.getColors()
    }

    getParameters() {
        // Width and height of the Simulation (in meters)
        this.simWidth = this.canvas.widthInput.value * 1
        this.simHeight = this.simWidth * this.height / this.width

        // Convert between pixels and meters
        this.pxToM = this.simWidth / this.width
        this.mToPx = this.width / this.simWidth
    }

    // Get all the points in the canvas
    getPoints() {
        let tempPoints = []
        for (let x = 0; x < this.width; x += this.STEP.x) {
            for (let y = 0; y < this.height; y += this.STEP.y) {
                tempPoints.push(new GravFieldPoint(x, y, this.STEP))
            }
        }
        this.points =  tempPoints
    }

    // When the user clicks on the canvas, create a Body on that point
    onClick(x, y, mass, color) {
        x = Math.round(x)
        y = Math.round(y)

        this.bodies.push(new GravBody(this, x, y, mass, color))

        // Add the field generated by the new body to the points on the cavnas
        this.update()
    }

    // When the canvas is resized, restart the simulation Object, while saving all the bodies
    onResize() {
        let temp = this.bodies ?? []
        this.start()
        this.bodies = temp
        
        // Resize the bodies' coordinates
        for (let index in this.bodies) {
            this.bodies[index].resize()
        }

        this.update(true)
        this.draw()
    }

    // Check if this value is the new min or max Gravity
    minMaxGravCheck(value) {
        if (value < this.minGrav) {
            this.minGrav = value
        } else if (value > this.maxGrav) {
            this.maxGrav = value
        }
    }

    // Generates the colors that will be used for showing the gravity
    getColors() {
        this.allColors = []

        // Get a spectrum of all colors between the two values, starting at the darkest and ending in the brightest color
        let currentColor = this.COLORS.minGrav
        let endColor = this.COLORS.maxGrav
        let diffArr = [0, 0, 0]
        let toBreak = false
        while (true) {
            // Save the color
            this.allColors.push(`rgb(${currentColor[0]},${currentColor[1]},${currentColor[2]})`)

            // Check with RGB value has the biggest difference between current and end values
            for (let i=0; i < 3; i++) {
                diffArr[i] = endColor[i] - currentColor[i]

                if (diffArr[i] < 0) {
                    toBreak = true
                }
            }

            if (toBreak) break

            // Shorten the gap between the RGB values that are farthest apart
            currentColor[diffArr.indexOf(Math.max(...diffArr))] += 1
        }
    }

    // Determine the color of each point
    colorPoints() {
        this.cPStorage = {
            numColors: this.allColors.length,
            gravDelta: this.maxGrav - this.minGrav,
            gravScale: undefined
        }

        // See the amount associated with each color
        this.cPStorage.gravScale = this.cPStorage.gravDelta / this.cPStorage.numColors
        for (let indexP in this.points) {
            let point = this.points[indexP]
            
            // See where this gravity is on the color Scale
            let colorIndex = Math.round(point.gravity.abs / this.cPStorage.gravScale)

            point.color = this.allColors[colorIndex]
        }
    }

    update(doAllBodies=false) {
        // Get each point and restart its gravity
        for (let indexP in this.points) {
            let point = this.points[indexP]

            // Recalculate gravity for every body we have
            if (doAllBodies) {
                point.gravity = new Vector2D(0, 0)
                for (let indexB in this.bodies) {
                    let body = this.bodies[indexB]
    
                    let gravity = gravityOnPoint(this, point, body)
    
                    point.gravity = point.gravity.add(gravity)
                }
            }

            // Only add the last body's gravity to the total
            else {
                let body = this.bodies[this.bodies.length - 1]

                let gravity = gravityOnPoint(this, point, body)
    
                point.gravity = point.gravity.add(gravity)
            }

            this.minMaxGravCheck(point.gravity.absThis())
        }

        this.colorPoints()

        this.draw()
    }

    draw() {
        // Clear the canvas
        this.ctx.clearRect(0, 0, this.width, this.height)

        // Color the points
        for (let index in this.points) {
            this.points[index].draw(this.ctx)
        }

        // Draw the bodies
        for (let index in this.bodies) {
            this.bodies[index].draw(this.ctx)
        }
    }
}